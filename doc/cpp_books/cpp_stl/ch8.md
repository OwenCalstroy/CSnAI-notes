# Chap 8: STL 仿函数

### 8.1 仿函数的概念

- 仿函数是定义了 operator() 的对象。
- 仿函数的优越之处：
  - 比一般函数更加灵巧，因为可以拥有状态。事实上对于仿函数，可以拥有两个状态的不同实体。
  - 每个仿函数都有其型别，可以将仿函数的型别当成 **template 参数**进行传递。
  - 执行速度仿函数通常比函数指针要快。

- 仿函数可当作排序准则。
- 仿函数拥有内部状态 internal state，仿函数在被实例化/初始化的时候就被给予状态，可以作为相同函数但有不同数值的总模板。“引用计数”方法：如果想要延续某一特定实例的作用，但在中间插入了其他部分，可以用 reference 来传递。
- for_each() 算法可以返回其仿函数，可以替代“引用计数”的方法。

### 8.2 预定义的仿函数

- ```cpp
  #include <functional>
  ```

- 函数配接器：能将仿函数和另一个仿函数/值/一般函数结合起来的仿函数。比如 bind2nd(..., ...) 将一个二元仿函数转换为一元仿函数，将第二参数传给“由第一参数指出”的二元仿函数。作为后者的第二参数。函数配接器本身也是仿函数，故可以结合仿函数以形成更强大/复杂的表达式。

- 针对成员函数设计的函数配接器：mem_fun_ref(...) 将原本“针对某个元素的函数调用动作”转为调用“被传递的成员函数”。因为我们不能直接将成员函数传给一个算法，因此需要放入 mem_fun_ref(...) 再传入。

- 针对一般函数设计的函数配接器：ptr_fun(...) 类似上面所述。

- 任何东西的行为只要像函数配接器，它就是一个函数配接器。

### 8.3 辅助用（组合型）仿函数

- 常用如下，需要自行实作：
  f(g(x));	f(g(x, y));	f(g(x), h(x));	f(g(x), h(y));

